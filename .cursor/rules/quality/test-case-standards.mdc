# ⚠️ 测试用例生成规范（Critical）

## 🧭 测试用例优先级定义（P0/P1/P2）

本项目使用 `pytest.mark.P0 / P1 / P2` 定义优先级（`pytest.ini` 已声明 markers）。

### P0（Critical / 主链路）

#### 📎 Allure 报告降噪（强制）

- Allure 只展示“前端证据步骤”（填写/提交/关键截图）
- baseline 修正/teardown 回滚/纯断言步骤默认不展示（用 ALLURE_SHOW_DEBUG/ALLURE_SHOW_BACKEND 按需打开）

- **定义**：主流程/关键路径；失败即功能不可用或阻塞上线。
- **必须覆盖**：
  - 页面加载（page load）
  - 主流程成功（happy path）
  - （推荐）必填校验覆盖：优先放在 **P1 字段矩阵**（更系统、可并发、少重复）；P0 可只保留 1 条代表性哨兵（避免用例膨胀）
- **强制（本次踩坑固化）**：
  - **P0 只用“正常数据”**：不得默认使用接近 `maxLength` 的超长字符串。
  - **baseline 必须“正常化”**：fixture 在进入用例前必须把表单修正到“可提交 + 正常长度”的 baseline（避免超长 baseline 污染 P0 截图/回滚/可读性）。
  - **写操作必须可回滚且可重复**：每条写操作用例必须恢复 baseline（fixture teardown 兜底），并保存一次确认可重复执行。



### ✅ 字段矩阵（强制，老兵口味）

当页面是“表单 + 保存（写接口）”时，输入校验应以 **P1 字段矩阵**为主：

- **按字段拆文件**：`test_<page>_p1_<field>_matrix.py`
- **should_save=False 的场景**必须设置 `require_frontend_error_evidence=True`
  - 含义：如果前端拦截（不发请求），必须有可见错误证据（validationMessage/aria-invalid/内联提示/invalid 样式）
- **后端 reject 探针**少而精：只对“典型且后端必拒绝”的非法值做 API reject 验证
- **避免重复**：若 P1 矩阵已覆盖必填/空白/非法格式，则 P0 不再单独堆每字段必填用例

### P1（High / 输入与异常的高风险点）
- **定义**：输入校验/边界/格式/关键异常处理；失败风险高但不一定阻塞所有用户。
- **必须覆盖（表单类）**：
  - 边界值：**min-1/min/min+1/max-1/max/max+1**（按字段维度）
  - 格式校验：正则/HTML5 validity/后端约束（以实际实现为准）
  - 关键业务规则：例如新旧密码相同禁止等
  - 常见异常：接口失败/超时（页面涉及 API 时）

### P2（Medium / 体验与健壮性）
- **定义**：UI/可用性/可访问性/交互细节；失败通常不影响核心功能，但影响体验与质量。
- **推荐最小集合**：字段可见性、tab 导航、键盘 Tab、必填标记展示、基础 a11y。

### `security`（横切维度，建议与 P* 叠加）
- **定义**：安全类用例使用 `@pytest.mark.security` 标记（不替代 P0/P1/P2）。
- **建议**：大多数安全用例风险等级接近 P1，可同时标记 `P1 + security`。
- **最小覆盖**：未登录访问受保护页面应进入登录流程、logout 后应被拦截、XSS 不执行、SQLi 风格输入不导致异常跳转。
- **控制变量原则（强制）**：
  - 安全测试的本质是验证"系统能否正确处理恶意输入"
  - **必须控制变量**：只改目标字段为恶意 payload，其余字段填合法值
  - **反例**：所有字段都填恶意值 → 无法定位是哪个字段导致的问题
  - **正例**：目标字段填 `<script>alert(1)</script>`，其余字段填 `validuser123` / `valid@test.com`

```python
# ❌ 错误：不控制变量（所有字段都是恶意值）
po.fill_username("<script>alert(1)</script>")
po.fill_email("<script>alert(1)</script>")
po.fill_password("<script>alert(1)</script>")

# ✅ 正确：控制变量（只有目标字段是恶意值）
baseline = {"username": "validuser", "email": "valid@test.com", "password": "ValidPass123!"}
po.fill_username(baseline["username"])
po.fill_email(baseline["email"])
po.fill_password(payload)  # 只有 password 是恶意 payload
```

---

## ✅ 强制：以前端可观测行为做断言，但以后端 ABP 为真理校准规则（前后端一致性）

目标：**不允许出现“前端放行 → 调后端才报错”的体验缺陷**。

### 规则（必须）
- **后端 ABP 规则是真理来源**：required/maxLength/pattern/minLength 等以 ABP DTO/OpenAPI 为准。
- **前端断言是第一优先**：所有校验相关用例，最终必须验证到“用户可见的前端表现”（错误提示/字段 invalid/按钮不可提交）。
- **一致性断言必须补上**（关键）：对“应被拒绝”的输入：
  - **前端必须拦截住**：断言“不会发出提交 API”（例如 `PUT /api/account/my-profile` 不应发生）
  - **后端 ABP 必须同样拒绝**：同一输入用 API 方式直连（带登录态 cookie/session），断言 4xx + 可诊断错误体（body/validationErrors）

### 实践建议（强烈建议）
- **规则快照**：每个页面至少 1 条 `*_abp_rules_snapshot` 用例，把 OpenAPI/Swagger 抽取出的字段规则挂到 Allure 附件（审计/对齐/排查 drift 用）。

---

## 🗂️ 测试目录组织规范（按模块/页面分目录）

当页面数量增多时，**必须按模块/页面建目录**，避免 `tests/` 根目录扁平堆积。

### 目录结构（推荐）

```
tests/
├── admin/
│   ├── profile/
│   │   ├── test_profile_settings_p0.py
│   │   ├── test_profile_settings_p1.py
│   │   ├── test_profile_settings_p2.py
│   │   └── test_profile_settings_security.py
│   └── users/
│       ├── ...
└── test_example.py  # 示例用例：必须使用 example 标记，不得混入 P0/P1/P2/security
```

### 文件数量控制（每页建议 2~4 个文件）

- **简单页面**：`p0+p1` 合并即可（1~2 个文件）
- **复杂页面**：拆分 `p2`、`security`（最多 3~4 个文件）
- **边界矩阵很大**：可额外拆 `p1_boundary_extra`（仅在必要时使用）

### 命名约定

- **页面目录**：`tests/<module>/<page>/`（如 `tests/admin/profile/`）
- **文件名**：`test_<page>_<priority>.py`
  - 例：`test_profile_settings_p0.py` / `test_profile_settings_p1.py` / `test_profile_settings_security.py`

### 执行方式（用 markers 管理，不靠文件名硬找）

- 只跑主回归：`-m P0`
- 只跑输入校验：`-m P1`
- 只跑体验/UI：`-m P2`
- 只跑安全：`-m security`（建议与 P1 叠加：`-m "P1 and security"`）

> 原则：目录表达"归属"（模块/页面），marker 表达"优先级/维度"（P0/P1/P2/security）。

---

## ✅ 强制：初次生成即参照前后端代码补全用例（不允许猜）

生成全量用例集（首次生成时）必须从**前端 + 后端**代码推导字段规则，并将来源写入测试（注释或 Allure step）。
禁止“先生成一堆骨架/数量达标，再等反馈补规则”。

### 前端规则来源（至少一种，默认必须读）
- 页面入口：Next.js `src/app/**/page.tsx` / React `src/pages/**` / 组件 `src/components/**`
- 表单校验：`react-hook-form register()` 的 `required/maxLength/minLength/pattern/validate`
- **HTML5 validity 必须考虑**：例如 `input type="email"` 可能被浏览器原生校验拦截 submit  
  → 此类用例优先断言“不会触发提交 API”，不要强绑错误文案（跨 OS/浏览器不稳定）

### 后端规则来源（至少一种，默认必须读）
- ABP DTO/Attribute：`[Required]` / `[StringLength]` / `[EmailAddress]` 等
- OpenAPI/SDK：`src/client/types.gen.ts` / `src/client/sdk.gen.ts` 的 DTO 与接口定义

### Security（必须按字段维度）
- 每个可编辑 input/select/textarea 都要跑最小载荷集（XSS/SQLi）并断言：
  - 不弹 dialog
  - 不异常跳转（不应被踢到登录页，除非是未登录用例）
  - 若触发提交 API：不应为 5xx
  - 用例结束必须恢复数据（避免污染账号池）

#### Security Payload 精简原则（强制）

**问题**：安全测试容易陷入"payload 堆积"陷阱（8个payload × 3字段 = 24条用例），但实际上：
- 如果前端做了统一转义/校验，所有 XSS payload 会有相同结果
- 如果后端用了参数化查询（ABP 默认），所有 SQLi payload 会有相同结果
- 冗余的 payload 只增加执行时间，不增加覆盖率

**精简方案**（5个代表性 payload，覆盖核心攻击向量）：

```python
_PAYLOADS = [
    # XSS 类：经典 script 注入
    ("xss_script", "<script>alert('XSS')</script>"),
    # XSS 类：事件触发型（img onerror）
    ("xss_img", "<img src=x onerror=alert('XSS')>"),
    
    # SQLi 类：经典逻辑绕过（OR 1=1）
    ("sqli_quote", "' OR '1'='1"),
    # SQLi 类：注释截断
    ("sqli_comment", "admin'--"),
    
    # HTML 注入：基础标签过滤测试
    ("html_bold", "<b>bold</b>"),
]
```

**移除的 payload 及理由**：
- ❌ `xss_svg` / `xss_iframe`：与 `xss_script` 本质相同，参数化转义会同时阻止
- ❌ `sqli_union` / `sqli_drop_table`：与 `sqli_quote` 同类，参数化查询会同时阻止
- ❌ `mixed_email_sqli`：与 `sqli_quote` 同类，测一个足够

**效果**：
- 3字段 × 5 payload = **15条用例**（vs 原来 21-24条）
- 执行时间减少 **~30%**
- 覆盖率**不降低**（XSS/SQLi/HTML注入的核心攻击向量都在）

**哲学**：能消失的分支永远比能写对的分支更优雅。

---

## 测试用例完整性检查清单

**生成测试用例时，必须确保覆盖以下场景：**

### P0 - 核心功能（必须覆盖）
- ✅ 页面加载测试
- ✅ 主流程成功场景
- ✅ **所有必填字段的验证**（每个必填字段都要有单独的测试用例）
  - 示例：表单有3个必填字段 → 需要3个P0测试用例分别验证

### P1 - 重要功能（必须覆盖）
- ✅ **边界值测试**（最小值、最大值、边界值）
  - 长度限制：必须测试 min-1, min, min+1, max-1, max, max+1
- ✅ **格式验证测试**（根据验证规则生成）
  - 正则表达式规则 → 生成对应的格式验证测试
- ✅ **业务逻辑验证**（规范中明确要求的场景）
- ✅ **API错误处理**（网络错误、服务器错误、超时）
- ✅ **前后端一致性**（强制）
  - invalid 输入：前端拦截（不发请求）+ 后端拒绝（4xx）

### P2 - 一般功能（可选）
- **推荐 P2 最小集合**：字段可见性、tab 导航、键盘 Tab 可用性、必填标记展示

---

## ❌ 常见错误（禁止）

### 1. 缺少断言

```python
# ❌ 错误：只有 logger.checkpoint，没有实际断言
logger.checkpoint("验证错误", True)

# ✅ 正确：必须有实际断言
assert change_password_page.has_validation_error(), "应该显示错误"
errors = change_password_page.get_validation_errors()
assert len(errors) > 0, "应该至少有一个验证错误"
```

### 2. 必填字段验证不完整

```python
# ❌ 错误：只验证了部分必填字段

# ✅ 正确：每个必填字段都要有单独的测试用例
def test_p0_current_password_required(...)
def test_p0_new_password_required(...)
def test_p0_confirm_password_required(...)
```

### 3. 边界值测试缺失

```python
# ❌ 错误：只测试了"太短"

# ✅ 正确：完整的边界值测试
def test_p1_password_too_short(...)        # 小于最小值
def test_p1_password_too_long(...)         # 大于最大值
def test_p1_password_boundary_values(...)  # 正好等于 min 和 max
```

### 4. 异常处理逻辑错误

```python
# ❌ 错误：在 except 块中重复操作已经消失的元素
try:
    with page.expect_navigation(timeout=20000):
        click_save(page)  # 点击成功，页面跳转
except Exception:
    click_save(page)  # ❌ 按钮已消失，导致失败

# ✅ 正确：异常后直接继续（点击已成功，只是等待超时）
try:
    with page.expect_navigation(timeout=20000):
        click_save(page)
except Exception:
    pass  # 点击已成功，只是导航等待超时（网络抖动）
```

**原则**：
- 异常处理应该**消除特殊分支**，而不是增加分支
- 如果操作已经成功，不要因为"等待超时"就重复操作
- **好品味**：能消失的分支永远比能写对的分支更优雅

---

## 🔐 Security 用例基线（当用户要求安全测试时，必须覆盖）

### 鉴权/会话（必须）
- ✅ **未登录访问受保护页面**：应被重定向到登录流程（如 `/auth/login` 或后端 `/Account/Login`）
- ✅ **logout 后访问受保护页面**：应再次进入登录流程（防止会话残留）

### 注入/脚本（必须）
- ✅ **XSS payload 不得执行**：输入 `<img src=x onerror=alert(1)>` 等载荷，页面不应弹出 dialog
- ✅ **SQLi 风格字符串不应导致异常行为**：如 `' OR 1=1 --`，页面不应崩溃/异常跳转

> 说明：安全用例的断言应以"系统不崩、无执行、无越权"为核心，避免强绑定具体 toast 文案。

---

## 🐛 Known Bugs 管理策略（强制）

### 问题：xfail 掩盖真相
传统做法是用 `@pytest.mark.xfail` 标记已知Bug，但这会导致：
- ❌ 报告中显示为"预期失败"（xfailed），通过率虚高（97% vs 74%）
- ❌ 已知Bug"安静地"隐藏在绿色背景中，无法引起重视
- ❌ Bug 修复后容易忘记移除 xfail 标记

### 解决方案：直接 FAIL（实用主义）

**原则**：**已知Bug应该在报告里"刺眼地"显示为失败，而不是"安静地"标记为预期失败。**

```python
# ❌ 错误：用 xfail 掩盖Bug
@pytest.mark.xfail(reason="REG-001: username注入导致500")
def test_security_injection_username():
    # ...
    assert resp.status < 500  # 实际会 500，但被 xfail 掩盖

# ✅ 正确：直接失败，刺眼地暴露问题
def test_security_injection_username():
    # ...
    assert resp.status < 500  # 失败 → 报告里显示红色 FAILED
```

**Known Bugs 台账管理**：
- 创建 `test_<page>_known_bugs.py`，集中定义 Bug ID 和描述
- 在失败用例的 `@allure.description()` 或注释中引用 Bug ID
- Allure 报告中会自动归类为 "Product defects"

```python
# tests/Account/Register/test_Register_known_bugs.py
BUG_REG_INJECTION_500 = "REG-002"
BUGS = {
    BUG_REG_INJECTION_500: {
        "title": "username/password注入导致500",
        "reason": "后端未正确处理特殊字符，导致500错误",
        "jira": "https://jira.example.com/browse/REG-002",
    }
}

# 在其他测试文件中引用（不使用 xfail）
@allure.description(f"已知Bug: {BUGS[BUG_REG_INJECTION_500]['title']}")
def test_security_injection_username():
    # 测试会失败，报告中显示为 Product defects
    pass
```

**效果**：
- 报告通过率真实反映质量（74% vs 虚高的 97%）
- Product defects 数量直观（13个红色失败，无法忽视）
- Bug 修复后，测试自然变绿，无需手动移除标记